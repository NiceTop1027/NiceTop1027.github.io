---
layout: single
title:  "😶‍🌫️ㅣ2024. 01. 22. 덕영고등학교ㅣ알고리즘 강의 (6일차) 백준 7 ~ 10 문제 풀이"
updated: 2024-1-21
---

## 백준 문제 풀이

이번 문제들은 자료구조와 매우 관련있는 문제인걸로 보입니다.
확실히 그 만큼 엄청 어려울 것이라고 예상합니다..

## 7 백준 3986ㅣ좋은 단어

이번 문제는 주어진 단어들에 대해 '좋은 단어'인지 확인하고 그 개수를 출력하는 문제 입니다.
딱 문제를 봤을때 드는 생각이 확실히 실버와 브론즈의 차이는 심하는다는걸 알 수 있었습니다..
이번 문제는 스택과 관련 있다는고는 생각했는데 확실히 아직 자료구조에 익숙하지 않아서 
제가 생각한것 처럼 제대로 되는 코드가 없더라구요..🥹
먼저 코드 보여드리겠습니다.

```cpp
#include <iostream>
#include <stack>
#include <string>
using namespace std;

int main() {
    int N;
    cin >> N;
    int G = 0;
    
    while (N--){
        string W;
        cin >> W;
        
        stack<char> st;
        
        for (char c : W){
            if (st.empty() || st.top() != c){
                st.push(c);
            } else{
                st.pop();
            }
        }
        
        if (st.empty()) G++;
    }
    
    cout << G << endl;
    return 0;
}

```

## 코드 설명

먼저 프로그램은 단어 수를 입력받고 각 단어를 하나씩 처리하게 합니다. 그리고 각 단어에서 문자를
순차적으로 확인하면서 스택에 문자를 쌓고 짝이 맞으면 스택에서 그 문자를 제거하는 구조 입니다. 
그러면 짝을 이룬 모든 문자가 제거되면서 스택이 비게 되고.. 스택이 비었을때가 그 단어는 좋은 단어로
결정하게 됩면서 출력되는 코드 입니다.

## 8 백준 1620ㅣ나는야 포켓몬 마스터 이다솜

이번 문제도 확실히 실버 문제라 그런지... 진짜진짜 너무 어렵습니다.
계속 머리속에서 드는 생각이만 자료구조에 대해 공부를 빠삭하게 하는게
좋다고 생각이 드네요 ㅋㅋㅋ.. 이번 문제 풀이는 이렇습니다.
앗 그리고 아무리 생각해도 도저히 잘 모르겠어서.. 구글링을 했봤습니다..ㅎㅎ
그리고 코드를 작성 후 디버깅을 통해 '이게 이렇게 되는구나!' 라는 딱 그 로직의 깨닮음을 통해
나중에 다시 한번 도전할 생각입니다!

```cpp
#include <iostream>
#include <unordered_map>
#include <vector>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int N, M;
    cin >> N >> M;

    vector<string> pokemons(N + 1); 
    unordered_map<string, int> pokemon_map;


    for (int i = 1; i <= N; ++i) {
        cin >> pokemons[i];
        pokemon_map[pokemons[i]] = i;
    }


    for (int i = 0; i < M; ++i) {
        string query;
        cin >> query;

        if (query[0] >= '0' && query[0] <= '9') {
            int num = stoi(query);
            cout << pokemons[num] << '\n';
        } else {
            cout << pokemon_map[query] << '\n';  
        }
    }

    return 0;
}
```
## 코드 설명

```cpp
int N, M;
cin >> N >> M;
```
먼저 N과 M을 입력받습니다. N은 포켓몬의 총 개수이고, M은 질문의 개수입니다.

```cpp
vector<string> pokemons(N + 1);
unordered_map<string, int> pokemon_map;
```
pokemons는 vector<string> 타입으로 포켓몬 번호에 해당하는 이름을 저장하기 위한 배열이고
배열의 크기는 N + 1로 1번부터 N번까지 포켓몬을 저장할 수 있습니다.
pokemon_map은 unordered_map<string, int> 타입으로 포켓몬 이름을 키로 해당 번호를 값으로 저장하는 맵입니다.
이 맵을 사용하여 포켓몬 이름을 빠르게 번호로 변환이 가능합니다!

```cpp
for (int i = 1; i <= N; ++i) {
    cin >> pokemons[i];
    pokemon_map[pokemons[i]] = i;
}
```
이 포문에서는 포켓몬 번호에 해당하는 이름을 입력받아 pokemons 배열에 저장하고 동시에 pokemon_map
에 포켓몬 이름과 번호를 저장합니다.

```cpp
for (int i = 0; i < M; ++i) {
    string query;
    cin >> query;
```
M번의 질문을 처리하는 포문이고 각 질문은 문자열 query로 입력됩니다. 이 각 포켓몬의 정보가 담겨져 있습니다.

```cpp
if (query[0] >= '0' && query[0] <= '9') {
    int num = stoi(query);
    cout << pokemons[num] << '\n';
} else {
    cout << pokemon_map[query] << '\n';
}
```
query가 숫자라면 첫 번째 문자가 숫인지 확인합니다.
(query[0] >= '0' && query[0] <= '9') 이때 stoi(query)로 문자열 query를 정수로 변환하고
해당 번호에 해당하는 포켓몬 이름을 pokemons[num]에서 찾아 출력합니다!!
하지만 만약 이름일 경우 pokemon_map[query]를 이용해 해당 이름에 해당하는 포켓몬 번호를 출력합니다.

이런식으로 숫자가 입력되면 해당 번호에 맞는 포켓몬 이름을 출력하고 이름이 입력 되면 해당 이름에 맞는 포켓몬 번호을 출력합니다.

## 9 백준 2559ㅣ수열

이번 문제는 연속적인 K일 동안의 온도 합이 가장 큰 값을 찾는 문제였습니다.
이번 문제도 실버 문제라서 굉장히 심각하게 어려웠던것 같습니다 짐어서 수학과 관련되어 있어서..
🥹 그래도 아무리 몰라도 바로 정답을 볼 순 없으니 몇시간 정도 생각이라도 해보자. 라는 마음가짐으로
직접 노트에다가 적으면서 머리속으로도 생각해보면서 해보았지만 잘되다가? 이땐 어떡하지? 라는 생각이 들어서
그때부터 갑자기 생각이 굳어버리게 되네요..🥹 먼저 문제 풀이 코드 입니다.

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    int N, K;
    cin >> N >> K;

    vector<int> t(N);  
    for (int i = 0; i < N; ++i) {
        cin >> t[i];  
    }

    int current_sum = 0;
    for (int i = 0; i < K; ++i) {
        current_sum += t[i]; 
    }

    int max_sum = current_sum; 


    for (int i = K; i < N; ++i) {
        current_sum += t[i] - t[i - K];
        max_sum = max(max_sum, current_sum);  
    }

    cout << max_sum << endl; 

    return 0;
}
```
## 코드 설명

```cpp
int N, K;
cin >> N >> K;
```
N은 온도 측정 일수 (전체 날짜의 수), K는 연속적으로 합을 구할 날짜 수입니다. 이 두 값을 입력받습니다.

```cpp
vector<int> temperatures(N);
for (int i = 0; i < N; ++i) {
    cin >> t[i];
}
```
t라는 벡터에 온도 데이터를 저장하고 N번의 온도를 입력받고 t 배열에 저장했습니다.

```cpp
int current_sum = 0;
for (int i = 0; i < K; ++i) {
    current_sum += t[i];
}
```
current_sum 변수에 첫 번째 K일 간의 온도의 합을 구합니다. 그리고 이 구간은
슬라이딩 윈도우의 첫 번째 구간이 됩니다.

여기서 슬라이딩 윈도우란 
```주어진 데이터를 처리하는 효율적인 알고리즘 기법 중 하나로, 주로 연속적인 부분 수열이나 부분 배열을 다룰 때 사용됩니다```

```cpp
int max_sum = current_sum;
```
첫 번째 구간의 합을 max_sum에 저장하고 이후에 다른 구간에서 나온 합들과 비교하여 가장 큰 합을 찾습니다.

```cpp
for (int i = K; i < N; ++i) {
    current_sum += temperatures[i] - temperatures[i - K];
    max_sum = max(max_sum, current_sum);
}
```
i는 K번째 인덱스부터 시작해서 끝까지 반복합니다. 그리고 
current_sum은 이전 구간의 합에 temperatures[i]를 더하고 temperatures[i - K]를 빼는 방식으로 계산합니다.
즉 이전 구간에서 첫 번째 온도 값을 빼고 새로 추가된 마지막 온도 값을 더하는 방식입니다!
