---
layout: single
title:  "🥳ㅣ2024. 01. 22. 덕영고등학교ㅣ알고리즘 강의 (6일차)"
updated: 2024-1-21
---

# 알고리즘 강의 (6일차) 정리

## 시작하기 전 개인적인 생각

이번 강의 내용은 순열 다음으로 **조합**에 대해 배웠습니다. 확실히 공식 부분은 순열과 조합을 비교하면 둘 다
이해하기는 쉬운데.. 역시 코드가 매우 어려웠던 것 같습니다. 제 생각에는 아직 저는 코드에 대한 익숙함이 조금 
부족하다고 생각합니다. 하지만 그래도 선생님이 많은 시간을 투자해주셔서 덕분에 친구들과 함께 협업하여 코드에
대한 조금이라도 이해가 되었습니다!! 이렇게 보니 제 자신이 처음 강의를 들었을 때와는 다르게 많은 발전이 있다
고 생각합니다. 처음에는 C++에 대한 개념 0.1%도 없이 들어왔습니다 ㅋㅋ.. 그래도 C언어나, 파이썬에 대한 개념이 있어
서 다행이라고 생각했습니다. 하지만 선생님께서 미리 강의 영상을 제공해주고 또한 수업시간에도 열심히 설명해 주셔서
지금까지 포기하지 않고 온 거라고 생각합니다. 선생님 말대로 "지금 이 내용이 이해가 되지 않는다면 나중에 대학을 가서라도 다시
공부하면 된다." 이 말이 저한테는 매우 감동적이였고 저에게도 힘이 됬습니다. 그 말을 들으면서 저는 이해가 안되는 부분이
있다면 개념이라도, 개념만이라도 이해해서 나중에 다시 공부하자! 라는 생각을 했습니다. 그런 마음가짐을 가진 덕분에
용기가 날 수 있었습니다. 그리고 방학기간인데도 불구하고 저희를 위해 열심히 강의해주셨는데 저도 나중에 대학생이 되거나
직장인이 되었을때 만약 시간이 남는다면 덕영고 학생들을 가르치고 싶다는 생각을 했습니다 ㅋㅋ :) 그 만큼 진심을
표현하고 싶었습니다!! 마지막으로  이제 곧 얼마 남지 않은 시간이지만 그 시간을 소중히 여기고 열심히 배워야겠다는
생각이 들었습니다. 솔직히 말해서 몇시간동안 앉아있으니 힘들긴 하더라구요.. 그래도 이번 시간만큼은 친구들과 
협업을 통해서 재밌게 느껴서 그런지 힘들지 않았습니다! ㅋㅋ 이렇게 수업을 진행하는 것도 나쁘지 않다고 생각했습니다 :)

## (조합)

오늘 배운 조합 공식 부분은 매우 간단합니다! 비록 코드 부분은 어렵긴 했지만요..ㅎ
조합 부분은 기존의 순열 부분과 비슷하다고 생각했습니다. 먼저 공식을 확인해 봅시다.
![](https://velog.velcdn.com/images/rladpwl0512/post/b5dcdb54-df6e-4b63-a1b6-f3648f8c5ce5/image.png)

먼저 간단하게 각 부분부터 소개해드리겠습니다!
```
1. n은 전체 원소의 개수 입니다.
2. k는 선택할 요소의 개수 입니다.
3. n!은 n의 팩토리얼로, n x (n - 1) x ------ x 1을 의미합니다. 
```
이처럼 조합 공식은 주어진 집합에서 특정 개수의 원소를 선택하는 경우의 수를 계산하는 공식입니다.
여기서 중요한 점은 C(n,k)는 순서를 고려하지 않는 경우의 수를 나타내므로순열과는 달리 원소들의 순서가 바뀌어도 동일한 선택으로 취급됩니다.
이때까지만 해도 매우 순조로웠지만... 조합 구조를 구현하는 방법 부분이 매우 어려웠습니다..🥹

먼저 조합 구조를 구현하는 방법으로 총 2가지가 있었습니다.
첫번째로는 재귀함수를 이용하거나 두번째 방법으로는 반복문을 이용하는 것 입니다.
제가 C언어에서 재귀함수를 구현할때는 간단하게 함수를 통해 (n-1) 반복하는걸만 아는데.... 생각보다 더욱
어렵더라구요 하하하하.. 일단 한번 재귀함수를 이용한 코드를 확인해 보겠습니다!

```cpp
#include <iostream>
#include <vector>

using namespace std;

void combi(vector<int> v, int st, int n, int r) {
    if (v.size() == r) {
        for (int i : v) {
            cout << i << " ";
        }
        cout << "\n";
        return;
    }

    for (int i = st; i <= n; i++) {
        v.push_back(i);
        combi(v, i + 1, n, r);
        v.pop_back();
    }
}

void combiFor(int n) {
    for (int i = 1; i <= n; i++) {
        for (int j = i + 1; j <= n; j++) {
            for (int k = j + 1; k <= n; k++) {
                cout << i << " " << j << " " << k << "\n";
            }
        }
    }
}

int main() {
    vector<int> v;
    //combi(v, 1, 5,3);

    combiFor(1,5,3);

    return 0;
}
```
